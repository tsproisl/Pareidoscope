#!/usr/bin/python
# -*- coding: utf-8 -*-

import argparse
import json

from pareidoscope.utils import nx_graph
from pareidoscope.utils import random_trees



if __name__ == "__main__":
# Ruler:
################################################################################
    description = "Create random trees, e.g. a corpus or a list of queries."
    epilog = """Examples:
  Create a random corpus of roughly 1,000,000 pseudo-words with default
  settings:
    pareidoscope_random_trees --cwb 1000000 > corpus_default_1M.txt

  Create a uniformly distributed corpus:
    pareidoscope_random_trees --voc-dist uniform --rel-dist uniform --cwb 1000000 > \\
      corpus_uni_1M.txt

  Create 100 queries with 2 to 5 vertices, uniformly distributed:
    pareidoscope_random_trees --voc-dist uniform --rel-dist uniform --sent-dist \\
      uniform --min-length 2 --max-length 5 --no-root --queries \\
      --trees 100 > queries_uni_100.txt"""
    parser = argparse.ArgumentParser(description=description, epilog=epilog, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument("-v", "--vocabulary", help="Vocabulary size (number of types); default: 2000", type=int, default=2000, metavar="N")
    parser.add_argument("--voc-dist", help="Distribution of vocabulary; default: zipf", choices=["zipf", "uniform"], default="zipf")
    parser.add_argument("-r", "--relations", help="Number of different dependency relations; default: 25", type=int, default=25, metavar="N")
    parser.add_argument("--rel-dist", help="Distribution of relations; default: zipf", choices=["zipf", "uniform"], default="zipf")
    parser.add_argument("--deg-dist", help="Distribution of degrees; default: zipf", choices=["zipf", "uniform"], default="zipf")
    parser.add_argument("--max-out-deg", help="Maximum out-degree; default: 10", type=int, default=10)
    parser.add_argument("--sent-dist", help="Distribution of sentence length; default: normal", choices=["normal", "uniform"], default="normal")

    parser.add_argument("--mu", help="Mean (only with normal distribution); default: 21.0", type=float, default=21.0)
    parser.add_argument("--sigma", help="Standard deviation (only with normal distribution); default: 8.0", type=float, default=8.0)
    parser.add_argument("--min-length", help="Minimum sentence length; default: 1", type=int, default=1, metavar="N")
    parser.add_argument("--max-length", help="Maximum sentence length; default: 50", type=int, default=50, metavar="N")
    group = parser.add_mutually_exclusive_group()
    group.add_argument("--queries", help="Split trees into two subtrees and output queries", action="store_true")
    group.add_argument("--cwb", help="Format output in CWB format: word pos lemma wc indeps outdeps", action="store_true")
    parser.add_argument("--underspec", help="Probability for a vertice or edge to be underspecified, i.e. to be labeled '.+'; default: 0.0", type=float, default=0.0)
    parser.add_argument("--no-root", help="Do not mark the root vertice", action="store_true")
    parser.add_argument("--trees", help="Interpret SIZE as number of trees to be generated", action="store_true")
    parser.add_argument("SIZE", help="Number of vertices to be generated", type=int)
    args = parser.parse_args()

    if args.cwb:
        print '<?xml version="1.0" encoding="UTF-8"?>'
        print "<corpus>"
    vocabulary = random_trees.create_distribution(args.vocabulary, args.voc_dist, "v")
    relations = random_trees.create_distribution(args.relations, args.rel_dist, "e")
    i, sid = 0, 0
    while i < args.SIZE:
        sid += 1
        length = random_trees.get_length(args.sent_dist, args.mu, args.sigma, args.min_length, args.max_length)
        tree = random_trees.get_random_tree(length, vocabulary, relations, args.deg_dist, args.max_out_deg, args.no_root, args.underspec)
        if args.queries:
            a, b, r1, c1, n = split_tree(tree)
            print "\t".join([json.dumps(nx_graph.export_to_adjacency_matrix(x)) for x in [tree, a, b, r1, c1, n]])
        elif args.cwb:
            print random_trees.cwb_format(tree, length, sid)
        else:
            print json.dumps(nx_graph.export_to_adjacency_matrix(tree))
        if args.trees:
            i += 1
        else:
            i += length
    if args.cwb:
        print "</corpus>"
