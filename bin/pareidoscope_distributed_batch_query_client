#!/usr/bin/python
# -*- coding: utf-8 -*-

import argparse
import multiprocessing
import multiprocessing.managers
import os
import random
import sys
import time
import Queue

import pareidoscope.query


def run_client(host, port, authkey, nprocs):
    manager = make_client_manager(host, port, authkey)
    job_q = manager.get_job_q()
    result_q = manager.get_result_q()
    mp_factorizer(job_q, result_q, nprocs)


def make_client_manager(host, port, authkey):
    """ Create a manager for a client. This manager connects to a
        server on the given address and exposes the get_job_q and
        get_result_q methods for accessing the shared queues from the
        server.  Return a manager object.
    """
    class ServerQueueManager(multiprocessing.managers.SyncManager):
        pass

    ServerQueueManager.register('get_job_q')
    ServerQueueManager.register('get_result_q')

    manager = ServerQueueManager(address=(host, port), authkey=authkey)
    manager.connect()

    # print 'Client connected to %s:%s' % (host, port)
    return manager


def mp_factorizer(shared_job_q, shared_result_q, nprocs):
    """ Split the work with jobs in shared_job_q and results in
        shared_result_q into several processes. Launch each process
        with run_queries as the worker function, and wait until all
        are finished.
    """
    procs = []
    for i in range(nprocs):
        p = multiprocessing.Process(target=run_queries, args=(shared_job_q, shared_result_q))
        procs.append(p)
        p.start()

    for p in procs:
        p.join()


def run_queries(input_queue, output_queue):
    """Run queries on graphs from input_queue and write output to
    output_queue.
    
    Arguments:
    - `input_queue`:
    - `output_queue`:
    - `queries`:
    """
    while True:
        try:
            results = []
            job = input_queue.get(block=True, timeout=5)
            sentences, queries = job
            for sentence in sentences:
                result = pareidoscope.query.run_query((sentence, queries))
                results.append(result)
            output_queue.put(results)
        except Queue.Empty:
            return



if __name__ == "__main__":
    if sys.version_info < (2, 7):
        raise Exception("Need at least Python 2.7!")
    os.nice(10)
    parser = argparse.ArgumentParser(description='Run a batch of queries against a corpus (client)')
    parser.add_argument("-o", "--host", type=str, help="IP or hostname", default="131.188.185.53")
    parser.add_argument("-p", "--port", type=int, help="Port", default=5662)
    parser.add_argument("-a", "--auth", type=str, help="Authkey", default="Ood4phee")
    args = parser.parse_args()

    # sleep between 0.1 and 5 seconds to limit stress on server
    time.sleep(random.uniform(0.1, 5))
    run_client(args.host, args.port, args.auth, multiprocessing.cpu_count())
